"""
Onboarding MCP Tools.

Tools for project onboarding and document publication.
"""

import json
import logging
from pathlib import Path
from typing import Dict

from fastmcp import Context
from mcp.server.session import ServerSession

from cde_orchestrator.adapters.prompt import PromptAdapter
from cde_orchestrator.adapters.repository.git_adapter import GitAdapter
from cde_orchestrator.adapters.state import StateAdapter
from cde_orchestrator.application.onboarding import OnboardingUseCase

from ._base import tool_handler

logger = logging.getLogger(__name__)

# Initialize services (will be moved to DI container later)
CDE_ROOT = Path(__file__).parent.parent.parent
PROMPT_RECIPES_DIR = CDE_ROOT / ".cde" / "prompts"
STATE_FILE = Path(".cde") / "state.json"

state_manager = StateAdapter(STATE_FILE)
prompt_manager = PromptAdapter()


@tool_handler
async def cde_onboardingProject(ctx: Context[ServerSession, None]) -> str:
    """
    Analyzes project structure and performs onboarding setup.
    Automatically detects if onboarding is needed and creates Spec-Kit compatible structure.
    Now includes AI assistant configuration following 2025 industry best practices.
    This is typically called when first connecting the MCP server to a new or existing project.

    Args:
        ctx: FastMCP Context for progress reporting and logging

    Returns:
        A contextualized prompt for the AI agent to execute onboarding,
        or a message if onboarding is not needed
    """
    # START: Progress tracking ðŸš€
    await ctx.info("ðŸš€ CDE Onboarding Analysis Started")
    await ctx.report_progress(0.0, 1.0, "Initializing onboarding analysis")

    project_root = Path.cwd()
    await ctx.debug(f"Project root: {project_root}")

    git_adapter = GitAdapter(project_root)
    analyzer = OnboardingUseCase(project_root, git_adapter)

    # Checkpoint 1: Structure scan (20%)
    await ctx.info("ðŸ“ Scanning project structure...")
    await ctx.report_progress(0.2, 1.0, "Scanning directory structure")

    # Check if onboarding is needed
    analysis = await analyzer.needs_onboarding()

    # Checkpoint 2: Analysis complete (40%)
    git_info = analysis.get("project_info", {}).get("git", {})
    commit_count = git_info.get("commit_count", 0)
    missing_count = len(analysis.get("missing_structure", []))

    await ctx.info(
        f"ðŸ“Š Analysis: {commit_count} commits, {missing_count} missing items"
    )
    await ctx.report_progress(0.4, 1.0, "Structure analysis complete")

    if not analysis["needs_onboarding"]:
        await ctx.info("âœ… Project already configured!")
        await ctx.report_progress(1.0, 1.0, "Analysis complete - no onboarding needed")
        return json.dumps(
            {
                "status": "already_configured",
                "message": "Project already has Spec-Kit compatible structure.",
                "existing_structure": analysis["existing_structure"],
            },
            indent=2,
        )

    # Checkpoint 3: Generate plan (60%)
    await ctx.info("ðŸ“ Generating onboarding plan...")
    await ctx.report_progress(0.6, 1.0, "Generating comprehensive plan")

    # Generate onboarding plan
    plan = await analyzer.generate_onboarding_plan()

    await ctx.debug(
        f"Plan generated: {len(plan.get('docs_to_generate', []))} docs, {len(plan.get('structure_to_create', []))} directories"
    )

    # Checkpoint 4: AI Assistant detection (75%)
    await ctx.info("ðŸ¤– Detecting AI assistants...")
    await ctx.report_progress(0.75, 1.0, "Detecting AI agents")

    # Detect AI assistants available on the system
    from cde_orchestrator.application.ai_config import AIConfigUseCase

    ai_configurator = AIConfigUseCase(project_root)
    detected_agents = ai_configurator.detect_installed_agents()
    ai_summary = ai_configurator.get_configuration_summary()

    if detected_agents:
        await ctx.info(f"âœ¨ Detected: {', '.join(detected_agents)}")
    else:
        await ctx.debug("No AI assistants detected")

    logger.info(
        f"Detected AI assistants: {', '.join(detected_agents) if detected_agents else 'none'}"
    )

    # Prepare context for POML prompt
    repo_digest = {
        "summary": "Repository digest will be generated by GitAdapter.",
        "tree": [],
        "top_files": [],
    }

    plan_context = plan.get("context", {})
    context = {
        "PROJECT_ANALYSIS": json.dumps(analysis, indent=2),
        "GIT_INSIGHTS": json.dumps(analysis["project_info"]["git"], indent=2),
        "MISSING_STRUCTURE": json.dumps(analysis["missing_structure"], indent=2),
        "TECH_STACK": json.dumps(analyzer._detect_tech_stack(), indent=2),
        "REPO_DIGEST": json.dumps(
            {
                "summary": repo_digest.get("summary"),
                "top_files": [
                    {"path": f["path"], "snippet": f["snippet"][:1000]}
                    for f in repo_digest.get("top_files", [])[:10]
                ],
            },
            indent=2,
        ),
        "REPO_SYNTHESIS": json.dumps(
            plan_context.get("repository_synthesis", {}), indent=2
        ),
        "CLEANUP_RECOMMENDATIONS": json.dumps(plan.get("cleanup_plan", {}), indent=2),
        "AI_ASSISTANTS": json.dumps(
            {
                "detected": detected_agents,
                "summary": ai_summary,
                "recommendation": "Configure AI assistant instruction files (AGENTS.md, GEMINI.md, .github/copilot-instructions.md) following 2025 industry standards.",
            },
            indent=2,
        ),
        "MANAGEMENT_PRINCIPLES": (
            "Specification-as-Code, Single Source of Truth (Git + Issues), Progressive Scalability, "
            "Automation-friendly structure for AI assistants. "
            "AI-First Documentation: AGENTS.md (OpenAI standard), GEMINI.md (Google AI Studio), "
            ".github/copilot-instructions.md (GitHub Copilot)."
        ),
    }

    # Checkpoint 5: Prepare prompt (90%)
    await ctx.info("ðŸ“„ Preparing onboarding prompt...")
    await ctx.report_progress(0.9, 1.0, "Loading prompt template")

    # Load and prepare onboarding prompt
    onboarding_prompt_path = PROMPT_RECIPES_DIR / "00_onboarding.poml"
    if not onboarding_prompt_path.exists():
        await ctx.error(f"âŒ Prompt template not found: {onboarding_prompt_path}")
        return json.dumps(
            {
                "error": "Onboarding prompt not found",
                "expected_path": str(onboarding_prompt_path),
            },
            indent=2,
        )

    try:
        final_prompt = prompt_manager.load_and_prepare(onboarding_prompt_path, context)

        # Save plan and prompt to state
        state = state_manager.load_state()
        if "onboarding" not in state:
            state["onboarding"] = {}
        state["onboarding"]["plan"] = plan
        state["onboarding"]["analysis"] = analysis
        state["onboarding"]["cleanup_plan"] = plan.get("cleanup_plan", {})
        state["onboarding"]["repository_synthesis"] = plan_context.get(
            "repository_synthesis", {}
        )
        state["onboarding"]["ai_assistants"] = {
            "detected": detected_agents,
            "summary": ai_summary,
        }
        state["onboarding"]["draft_prompt"] = final_prompt
        state["onboarding"]["repo_digest"] = repo_digest
        state["onboarding"]["awaiting_approval"] = True
        state_manager.save_state(state)

        # Checkpoint 6: Complete! (100%)
        await ctx.info("âœ… Onboarding draft ready!")
        await ctx.report_progress(1.0, 1.0, "Complete - awaiting document generation")

        await ctx.info(
            "ðŸ“‹ Next: Use LLM to generate documents, then call cde_publishOnboarding"
        )

        return json.dumps(
            {
                "status": "draft_ready",
                "message": "Onboarding draft prompt prepared. Use an LLM to generate documents, then call cde_publishOnboarding to apply after human approval.",
                "draft_preview": final_prompt[:2000],
                "detected_agents": detected_agents,
                "missing_count": missing_count,
                "commit_count": commit_count,
            },
            indent=2,
        )
    except Exception as exc:
        logger.exception("Error generating onboarding prompt")
        await ctx.error(f"âŒ Failed to generate prompt: {str(exc)}")
        return json.dumps(
            {"error": "onboarding_prompt_failed", "message": str(exc)}, indent=2
        )


@tool_handler
def cde_publishOnboarding(documents: Dict[str, str], approve: bool = True) -> str:
    """Apply onboarding documents generated by an LLM into the repo.

    Args:
        documents: mapping file_path -> content (relative to project root)
        approve: boolean that confirms the user approves writing these files

    Returns:
        status message
    """
    project_root = Path.cwd()
    state = state_manager.load_state()
    onboarding = state.get("onboarding", {})

    if not onboarding.get("awaiting_approval"):
        return json.dumps(
            {
                "error": "no_onboarding_pending",
                "message": "Run cde_onboardingProject first.",
            },
            indent=2,
        )

    if not approve:
        onboarding["awaiting_approval"] = False
        onboarding["approved"] = False
        state_manager.save_state(state)
        return json.dumps(
            {"status": "declined", "message": "Onboarding draft declined by user."},
            indent=2,
        )

    # Apply documents
    created = []
    failed = []
    for path, content in (documents or {}).items():
        try:
            dest = project_root / path
            dest.parent.mkdir(parents=True, exist_ok=True)
            dest.write_text(content, encoding="utf-8")
            created.append(str(dest.relative_to(project_root)))
        except Exception as e:
            failed.append({"path": path, "error": str(e)})

    onboarding["awaiting_approval"] = False
    onboarding["approved"] = True
    onboarding["created_files"] = created
    onboarding["failed_writes"] = failed
    state_manager.save_state(state)

    return json.dumps(
        {"status": "applied", "created": created, "failed": failed}, indent=2
    )
